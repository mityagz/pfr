// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: capability.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_capability_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_capability_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "gobgp.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_capability_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_capability_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_capability_2eproto;
namespace apipb {
class AddPathCapability;
class AddPathCapabilityDefaultTypeInternal;
extern AddPathCapabilityDefaultTypeInternal _AddPathCapability_default_instance_;
class AddPathCapabilityTuple;
class AddPathCapabilityTupleDefaultTypeInternal;
extern AddPathCapabilityTupleDefaultTypeInternal _AddPathCapabilityTuple_default_instance_;
class CarryingLabelInfoCapability;
class CarryingLabelInfoCapabilityDefaultTypeInternal;
extern CarryingLabelInfoCapabilityDefaultTypeInternal _CarryingLabelInfoCapability_default_instance_;
class EnhancedRouteRefreshCapability;
class EnhancedRouteRefreshCapabilityDefaultTypeInternal;
extern EnhancedRouteRefreshCapabilityDefaultTypeInternal _EnhancedRouteRefreshCapability_default_instance_;
class ExtendedNexthopCapability;
class ExtendedNexthopCapabilityDefaultTypeInternal;
extern ExtendedNexthopCapabilityDefaultTypeInternal _ExtendedNexthopCapability_default_instance_;
class ExtendedNexthopCapabilityTuple;
class ExtendedNexthopCapabilityTupleDefaultTypeInternal;
extern ExtendedNexthopCapabilityTupleDefaultTypeInternal _ExtendedNexthopCapabilityTuple_default_instance_;
class FourOctetASNCapability;
class FourOctetASNCapabilityDefaultTypeInternal;
extern FourOctetASNCapabilityDefaultTypeInternal _FourOctetASNCapability_default_instance_;
class FqdnCapability;
class FqdnCapabilityDefaultTypeInternal;
extern FqdnCapabilityDefaultTypeInternal _FqdnCapability_default_instance_;
class GracefulRestartCapability;
class GracefulRestartCapabilityDefaultTypeInternal;
extern GracefulRestartCapabilityDefaultTypeInternal _GracefulRestartCapability_default_instance_;
class GracefulRestartCapabilityTuple;
class GracefulRestartCapabilityTupleDefaultTypeInternal;
extern GracefulRestartCapabilityTupleDefaultTypeInternal _GracefulRestartCapabilityTuple_default_instance_;
class LongLivedGracefulRestartCapability;
class LongLivedGracefulRestartCapabilityDefaultTypeInternal;
extern LongLivedGracefulRestartCapabilityDefaultTypeInternal _LongLivedGracefulRestartCapability_default_instance_;
class LongLivedGracefulRestartCapabilityTuple;
class LongLivedGracefulRestartCapabilityTupleDefaultTypeInternal;
extern LongLivedGracefulRestartCapabilityTupleDefaultTypeInternal _LongLivedGracefulRestartCapabilityTuple_default_instance_;
class MultiProtocolCapability;
class MultiProtocolCapabilityDefaultTypeInternal;
extern MultiProtocolCapabilityDefaultTypeInternal _MultiProtocolCapability_default_instance_;
class RouteRefreshCapability;
class RouteRefreshCapabilityDefaultTypeInternal;
extern RouteRefreshCapabilityDefaultTypeInternal _RouteRefreshCapability_default_instance_;
class RouteRefreshCiscoCapability;
class RouteRefreshCiscoCapabilityDefaultTypeInternal;
extern RouteRefreshCiscoCapabilityDefaultTypeInternal _RouteRefreshCiscoCapability_default_instance_;
class SoftwareVersionCapability;
class SoftwareVersionCapabilityDefaultTypeInternal;
extern SoftwareVersionCapabilityDefaultTypeInternal _SoftwareVersionCapability_default_instance_;
class UnknownCapability;
class UnknownCapabilityDefaultTypeInternal;
extern UnknownCapabilityDefaultTypeInternal _UnknownCapability_default_instance_;
}  // namespace apipb
PROTOBUF_NAMESPACE_OPEN
template<> ::apipb::AddPathCapability* Arena::CreateMaybeMessage<::apipb::AddPathCapability>(Arena*);
template<> ::apipb::AddPathCapabilityTuple* Arena::CreateMaybeMessage<::apipb::AddPathCapabilityTuple>(Arena*);
template<> ::apipb::CarryingLabelInfoCapability* Arena::CreateMaybeMessage<::apipb::CarryingLabelInfoCapability>(Arena*);
template<> ::apipb::EnhancedRouteRefreshCapability* Arena::CreateMaybeMessage<::apipb::EnhancedRouteRefreshCapability>(Arena*);
template<> ::apipb::ExtendedNexthopCapability* Arena::CreateMaybeMessage<::apipb::ExtendedNexthopCapability>(Arena*);
template<> ::apipb::ExtendedNexthopCapabilityTuple* Arena::CreateMaybeMessage<::apipb::ExtendedNexthopCapabilityTuple>(Arena*);
template<> ::apipb::FourOctetASNCapability* Arena::CreateMaybeMessage<::apipb::FourOctetASNCapability>(Arena*);
template<> ::apipb::FqdnCapability* Arena::CreateMaybeMessage<::apipb::FqdnCapability>(Arena*);
template<> ::apipb::GracefulRestartCapability* Arena::CreateMaybeMessage<::apipb::GracefulRestartCapability>(Arena*);
template<> ::apipb::GracefulRestartCapabilityTuple* Arena::CreateMaybeMessage<::apipb::GracefulRestartCapabilityTuple>(Arena*);
template<> ::apipb::LongLivedGracefulRestartCapability* Arena::CreateMaybeMessage<::apipb::LongLivedGracefulRestartCapability>(Arena*);
template<> ::apipb::LongLivedGracefulRestartCapabilityTuple* Arena::CreateMaybeMessage<::apipb::LongLivedGracefulRestartCapabilityTuple>(Arena*);
template<> ::apipb::MultiProtocolCapability* Arena::CreateMaybeMessage<::apipb::MultiProtocolCapability>(Arena*);
template<> ::apipb::RouteRefreshCapability* Arena::CreateMaybeMessage<::apipb::RouteRefreshCapability>(Arena*);
template<> ::apipb::RouteRefreshCiscoCapability* Arena::CreateMaybeMessage<::apipb::RouteRefreshCiscoCapability>(Arena*);
template<> ::apipb::SoftwareVersionCapability* Arena::CreateMaybeMessage<::apipb::SoftwareVersionCapability>(Arena*);
template<> ::apipb::UnknownCapability* Arena::CreateMaybeMessage<::apipb::UnknownCapability>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace apipb {

enum AddPathCapabilityTuple_Mode : int {
  AddPathCapabilityTuple_Mode_NONE = 0,
  AddPathCapabilityTuple_Mode_RECEIVE = 1,
  AddPathCapabilityTuple_Mode_SEND = 2,
  AddPathCapabilityTuple_Mode_BOTH = 3,
  AddPathCapabilityTuple_Mode_AddPathCapabilityTuple_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AddPathCapabilityTuple_Mode_AddPathCapabilityTuple_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AddPathCapabilityTuple_Mode_IsValid(int value);
constexpr AddPathCapabilityTuple_Mode AddPathCapabilityTuple_Mode_Mode_MIN = AddPathCapabilityTuple_Mode_NONE;
constexpr AddPathCapabilityTuple_Mode AddPathCapabilityTuple_Mode_Mode_MAX = AddPathCapabilityTuple_Mode_BOTH;
constexpr int AddPathCapabilityTuple_Mode_Mode_ARRAYSIZE = AddPathCapabilityTuple_Mode_Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AddPathCapabilityTuple_Mode_descriptor();
template<typename T>
inline const std::string& AddPathCapabilityTuple_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AddPathCapabilityTuple_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AddPathCapabilityTuple_Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AddPathCapabilityTuple_Mode_descriptor(), enum_t_value);
}
inline bool AddPathCapabilityTuple_Mode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AddPathCapabilityTuple_Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AddPathCapabilityTuple_Mode>(
    AddPathCapabilityTuple_Mode_descriptor(), name, value);
}
// ===================================================================

class MultiProtocolCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.MultiProtocolCapability) */ {
 public:
  inline MultiProtocolCapability() : MultiProtocolCapability(nullptr) {}
  virtual ~MultiProtocolCapability();

  MultiProtocolCapability(const MultiProtocolCapability& from);
  MultiProtocolCapability(MultiProtocolCapability&& from) noexcept
    : MultiProtocolCapability() {
    *this = ::std::move(from);
  }

  inline MultiProtocolCapability& operator=(const MultiProtocolCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiProtocolCapability& operator=(MultiProtocolCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MultiProtocolCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiProtocolCapability* internal_default_instance() {
    return reinterpret_cast<const MultiProtocolCapability*>(
               &_MultiProtocolCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MultiProtocolCapability& a, MultiProtocolCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiProtocolCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiProtocolCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiProtocolCapability* New() const final {
    return CreateMaybeMessage<MultiProtocolCapability>(nullptr);
  }

  MultiProtocolCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiProtocolCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MultiProtocolCapability& from);
  void MergeFrom(const MultiProtocolCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiProtocolCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.MultiProtocolCapability";
  }
  protected:
  explicit MultiProtocolCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFamilyFieldNumber = 1,
  };
  // .apipb.Family family = 1;
  bool has_family() const;
  private:
  bool _internal_has_family() const;
  public:
  void clear_family();
  const ::apipb::Family& family() const;
  ::apipb::Family* release_family();
  ::apipb::Family* mutable_family();
  void set_allocated_family(::apipb::Family* family);
  private:
  const ::apipb::Family& _internal_family() const;
  ::apipb::Family* _internal_mutable_family();
  public:
  void unsafe_arena_set_allocated_family(
      ::apipb::Family* family);
  ::apipb::Family* unsafe_arena_release_family();

  // @@protoc_insertion_point(class_scope:apipb.MultiProtocolCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::apipb::Family* family_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// -------------------------------------------------------------------

class RouteRefreshCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.RouteRefreshCapability) */ {
 public:
  inline RouteRefreshCapability() : RouteRefreshCapability(nullptr) {}
  virtual ~RouteRefreshCapability();

  RouteRefreshCapability(const RouteRefreshCapability& from);
  RouteRefreshCapability(RouteRefreshCapability&& from) noexcept
    : RouteRefreshCapability() {
    *this = ::std::move(from);
  }

  inline RouteRefreshCapability& operator=(const RouteRefreshCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteRefreshCapability& operator=(RouteRefreshCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RouteRefreshCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteRefreshCapability* internal_default_instance() {
    return reinterpret_cast<const RouteRefreshCapability*>(
               &_RouteRefreshCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RouteRefreshCapability& a, RouteRefreshCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteRefreshCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteRefreshCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RouteRefreshCapability* New() const final {
    return CreateMaybeMessage<RouteRefreshCapability>(nullptr);
  }

  RouteRefreshCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteRefreshCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RouteRefreshCapability& from);
  void MergeFrom(const RouteRefreshCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteRefreshCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.RouteRefreshCapability";
  }
  protected:
  explicit RouteRefreshCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apipb.RouteRefreshCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// -------------------------------------------------------------------

class CarryingLabelInfoCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.CarryingLabelInfoCapability) */ {
 public:
  inline CarryingLabelInfoCapability() : CarryingLabelInfoCapability(nullptr) {}
  virtual ~CarryingLabelInfoCapability();

  CarryingLabelInfoCapability(const CarryingLabelInfoCapability& from);
  CarryingLabelInfoCapability(CarryingLabelInfoCapability&& from) noexcept
    : CarryingLabelInfoCapability() {
    *this = ::std::move(from);
  }

  inline CarryingLabelInfoCapability& operator=(const CarryingLabelInfoCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarryingLabelInfoCapability& operator=(CarryingLabelInfoCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CarryingLabelInfoCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CarryingLabelInfoCapability* internal_default_instance() {
    return reinterpret_cast<const CarryingLabelInfoCapability*>(
               &_CarryingLabelInfoCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CarryingLabelInfoCapability& a, CarryingLabelInfoCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(CarryingLabelInfoCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarryingLabelInfoCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CarryingLabelInfoCapability* New() const final {
    return CreateMaybeMessage<CarryingLabelInfoCapability>(nullptr);
  }

  CarryingLabelInfoCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CarryingLabelInfoCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CarryingLabelInfoCapability& from);
  void MergeFrom(const CarryingLabelInfoCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarryingLabelInfoCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.CarryingLabelInfoCapability";
  }
  protected:
  explicit CarryingLabelInfoCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apipb.CarryingLabelInfoCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// -------------------------------------------------------------------

class ExtendedNexthopCapabilityTuple PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.ExtendedNexthopCapabilityTuple) */ {
 public:
  inline ExtendedNexthopCapabilityTuple() : ExtendedNexthopCapabilityTuple(nullptr) {}
  virtual ~ExtendedNexthopCapabilityTuple();

  ExtendedNexthopCapabilityTuple(const ExtendedNexthopCapabilityTuple& from);
  ExtendedNexthopCapabilityTuple(ExtendedNexthopCapabilityTuple&& from) noexcept
    : ExtendedNexthopCapabilityTuple() {
    *this = ::std::move(from);
  }

  inline ExtendedNexthopCapabilityTuple& operator=(const ExtendedNexthopCapabilityTuple& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtendedNexthopCapabilityTuple& operator=(ExtendedNexthopCapabilityTuple&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExtendedNexthopCapabilityTuple& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExtendedNexthopCapabilityTuple* internal_default_instance() {
    return reinterpret_cast<const ExtendedNexthopCapabilityTuple*>(
               &_ExtendedNexthopCapabilityTuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ExtendedNexthopCapabilityTuple& a, ExtendedNexthopCapabilityTuple& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtendedNexthopCapabilityTuple* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtendedNexthopCapabilityTuple* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExtendedNexthopCapabilityTuple* New() const final {
    return CreateMaybeMessage<ExtendedNexthopCapabilityTuple>(nullptr);
  }

  ExtendedNexthopCapabilityTuple* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExtendedNexthopCapabilityTuple>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExtendedNexthopCapabilityTuple& from);
  void MergeFrom(const ExtendedNexthopCapabilityTuple& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExtendedNexthopCapabilityTuple* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.ExtendedNexthopCapabilityTuple";
  }
  protected:
  explicit ExtendedNexthopCapabilityTuple(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNlriFamilyFieldNumber = 1,
    kNexthopFamilyFieldNumber = 2,
  };
  // .apipb.Family nlri_family = 1;
  bool has_nlri_family() const;
  private:
  bool _internal_has_nlri_family() const;
  public:
  void clear_nlri_family();
  const ::apipb::Family& nlri_family() const;
  ::apipb::Family* release_nlri_family();
  ::apipb::Family* mutable_nlri_family();
  void set_allocated_nlri_family(::apipb::Family* nlri_family);
  private:
  const ::apipb::Family& _internal_nlri_family() const;
  ::apipb::Family* _internal_mutable_nlri_family();
  public:
  void unsafe_arena_set_allocated_nlri_family(
      ::apipb::Family* nlri_family);
  ::apipb::Family* unsafe_arena_release_nlri_family();

  // .apipb.Family nexthop_family = 2;
  bool has_nexthop_family() const;
  private:
  bool _internal_has_nexthop_family() const;
  public:
  void clear_nexthop_family();
  const ::apipb::Family& nexthop_family() const;
  ::apipb::Family* release_nexthop_family();
  ::apipb::Family* mutable_nexthop_family();
  void set_allocated_nexthop_family(::apipb::Family* nexthop_family);
  private:
  const ::apipb::Family& _internal_nexthop_family() const;
  ::apipb::Family* _internal_mutable_nexthop_family();
  public:
  void unsafe_arena_set_allocated_nexthop_family(
      ::apipb::Family* nexthop_family);
  ::apipb::Family* unsafe_arena_release_nexthop_family();

  // @@protoc_insertion_point(class_scope:apipb.ExtendedNexthopCapabilityTuple)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::apipb::Family* nlri_family_;
  ::apipb::Family* nexthop_family_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// -------------------------------------------------------------------

class ExtendedNexthopCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.ExtendedNexthopCapability) */ {
 public:
  inline ExtendedNexthopCapability() : ExtendedNexthopCapability(nullptr) {}
  virtual ~ExtendedNexthopCapability();

  ExtendedNexthopCapability(const ExtendedNexthopCapability& from);
  ExtendedNexthopCapability(ExtendedNexthopCapability&& from) noexcept
    : ExtendedNexthopCapability() {
    *this = ::std::move(from);
  }

  inline ExtendedNexthopCapability& operator=(const ExtendedNexthopCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtendedNexthopCapability& operator=(ExtendedNexthopCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExtendedNexthopCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExtendedNexthopCapability* internal_default_instance() {
    return reinterpret_cast<const ExtendedNexthopCapability*>(
               &_ExtendedNexthopCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ExtendedNexthopCapability& a, ExtendedNexthopCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtendedNexthopCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtendedNexthopCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExtendedNexthopCapability* New() const final {
    return CreateMaybeMessage<ExtendedNexthopCapability>(nullptr);
  }

  ExtendedNexthopCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExtendedNexthopCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExtendedNexthopCapability& from);
  void MergeFrom(const ExtendedNexthopCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExtendedNexthopCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.ExtendedNexthopCapability";
  }
  protected:
  explicit ExtendedNexthopCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTuplesFieldNumber = 1,
  };
  // repeated .apipb.ExtendedNexthopCapabilityTuple tuples = 1;
  int tuples_size() const;
  private:
  int _internal_tuples_size() const;
  public:
  void clear_tuples();
  ::apipb::ExtendedNexthopCapabilityTuple* mutable_tuples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::ExtendedNexthopCapabilityTuple >*
      mutable_tuples();
  private:
  const ::apipb::ExtendedNexthopCapabilityTuple& _internal_tuples(int index) const;
  ::apipb::ExtendedNexthopCapabilityTuple* _internal_add_tuples();
  public:
  const ::apipb::ExtendedNexthopCapabilityTuple& tuples(int index) const;
  ::apipb::ExtendedNexthopCapabilityTuple* add_tuples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::ExtendedNexthopCapabilityTuple >&
      tuples() const;

  // @@protoc_insertion_point(class_scope:apipb.ExtendedNexthopCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::ExtendedNexthopCapabilityTuple > tuples_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// -------------------------------------------------------------------

class GracefulRestartCapabilityTuple PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.GracefulRestartCapabilityTuple) */ {
 public:
  inline GracefulRestartCapabilityTuple() : GracefulRestartCapabilityTuple(nullptr) {}
  virtual ~GracefulRestartCapabilityTuple();

  GracefulRestartCapabilityTuple(const GracefulRestartCapabilityTuple& from);
  GracefulRestartCapabilityTuple(GracefulRestartCapabilityTuple&& from) noexcept
    : GracefulRestartCapabilityTuple() {
    *this = ::std::move(from);
  }

  inline GracefulRestartCapabilityTuple& operator=(const GracefulRestartCapabilityTuple& from) {
    CopyFrom(from);
    return *this;
  }
  inline GracefulRestartCapabilityTuple& operator=(GracefulRestartCapabilityTuple&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GracefulRestartCapabilityTuple& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GracefulRestartCapabilityTuple* internal_default_instance() {
    return reinterpret_cast<const GracefulRestartCapabilityTuple*>(
               &_GracefulRestartCapabilityTuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GracefulRestartCapabilityTuple& a, GracefulRestartCapabilityTuple& b) {
    a.Swap(&b);
  }
  inline void Swap(GracefulRestartCapabilityTuple* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GracefulRestartCapabilityTuple* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GracefulRestartCapabilityTuple* New() const final {
    return CreateMaybeMessage<GracefulRestartCapabilityTuple>(nullptr);
  }

  GracefulRestartCapabilityTuple* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GracefulRestartCapabilityTuple>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GracefulRestartCapabilityTuple& from);
  void MergeFrom(const GracefulRestartCapabilityTuple& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GracefulRestartCapabilityTuple* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.GracefulRestartCapabilityTuple";
  }
  protected:
  explicit GracefulRestartCapabilityTuple(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFamilyFieldNumber = 1,
    kFlagsFieldNumber = 2,
  };
  // .apipb.Family family = 1;
  bool has_family() const;
  private:
  bool _internal_has_family() const;
  public:
  void clear_family();
  const ::apipb::Family& family() const;
  ::apipb::Family* release_family();
  ::apipb::Family* mutable_family();
  void set_allocated_family(::apipb::Family* family);
  private:
  const ::apipb::Family& _internal_family() const;
  ::apipb::Family* _internal_mutable_family();
  public:
  void unsafe_arena_set_allocated_family(
      ::apipb::Family* family);
  ::apipb::Family* unsafe_arena_release_family();

  // uint32 flags = 2;
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_flags() const;
  void _internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:apipb.GracefulRestartCapabilityTuple)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::apipb::Family* family_;
  ::PROTOBUF_NAMESPACE_ID::uint32 flags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// -------------------------------------------------------------------

class GracefulRestartCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.GracefulRestartCapability) */ {
 public:
  inline GracefulRestartCapability() : GracefulRestartCapability(nullptr) {}
  virtual ~GracefulRestartCapability();

  GracefulRestartCapability(const GracefulRestartCapability& from);
  GracefulRestartCapability(GracefulRestartCapability&& from) noexcept
    : GracefulRestartCapability() {
    *this = ::std::move(from);
  }

  inline GracefulRestartCapability& operator=(const GracefulRestartCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline GracefulRestartCapability& operator=(GracefulRestartCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GracefulRestartCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GracefulRestartCapability* internal_default_instance() {
    return reinterpret_cast<const GracefulRestartCapability*>(
               &_GracefulRestartCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GracefulRestartCapability& a, GracefulRestartCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(GracefulRestartCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GracefulRestartCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GracefulRestartCapability* New() const final {
    return CreateMaybeMessage<GracefulRestartCapability>(nullptr);
  }

  GracefulRestartCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GracefulRestartCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GracefulRestartCapability& from);
  void MergeFrom(const GracefulRestartCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GracefulRestartCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.GracefulRestartCapability";
  }
  protected:
  explicit GracefulRestartCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTuplesFieldNumber = 3,
    kFlagsFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // repeated .apipb.GracefulRestartCapabilityTuple tuples = 3;
  int tuples_size() const;
  private:
  int _internal_tuples_size() const;
  public:
  void clear_tuples();
  ::apipb::GracefulRestartCapabilityTuple* mutable_tuples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::GracefulRestartCapabilityTuple >*
      mutable_tuples();
  private:
  const ::apipb::GracefulRestartCapabilityTuple& _internal_tuples(int index) const;
  ::apipb::GracefulRestartCapabilityTuple* _internal_add_tuples();
  public:
  const ::apipb::GracefulRestartCapabilityTuple& tuples(int index) const;
  ::apipb::GracefulRestartCapabilityTuple* add_tuples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::GracefulRestartCapabilityTuple >&
      tuples() const;

  // uint32 flags = 1;
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_flags() const;
  void _internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 time = 2;
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::uint32 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:apipb.GracefulRestartCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::GracefulRestartCapabilityTuple > tuples_;
  ::PROTOBUF_NAMESPACE_ID::uint32 flags_;
  ::PROTOBUF_NAMESPACE_ID::uint32 time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// -------------------------------------------------------------------

class FourOctetASNCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.FourOctetASNCapability) */ {
 public:
  inline FourOctetASNCapability() : FourOctetASNCapability(nullptr) {}
  virtual ~FourOctetASNCapability();

  FourOctetASNCapability(const FourOctetASNCapability& from);
  FourOctetASNCapability(FourOctetASNCapability&& from) noexcept
    : FourOctetASNCapability() {
    *this = ::std::move(from);
  }

  inline FourOctetASNCapability& operator=(const FourOctetASNCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline FourOctetASNCapability& operator=(FourOctetASNCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FourOctetASNCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FourOctetASNCapability* internal_default_instance() {
    return reinterpret_cast<const FourOctetASNCapability*>(
               &_FourOctetASNCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FourOctetASNCapability& a, FourOctetASNCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(FourOctetASNCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FourOctetASNCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FourOctetASNCapability* New() const final {
    return CreateMaybeMessage<FourOctetASNCapability>(nullptr);
  }

  FourOctetASNCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FourOctetASNCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FourOctetASNCapability& from);
  void MergeFrom(const FourOctetASNCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FourOctetASNCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.FourOctetASNCapability";
  }
  protected:
  explicit FourOctetASNCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAsnFieldNumber = 1,
  };
  // uint32 asn = 1;
  void clear_asn();
  ::PROTOBUF_NAMESPACE_ID::uint32 asn() const;
  void set_asn(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_asn() const;
  void _internal_set_asn(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:apipb.FourOctetASNCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 asn_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// -------------------------------------------------------------------

class AddPathCapabilityTuple PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.AddPathCapabilityTuple) */ {
 public:
  inline AddPathCapabilityTuple() : AddPathCapabilityTuple(nullptr) {}
  virtual ~AddPathCapabilityTuple();

  AddPathCapabilityTuple(const AddPathCapabilityTuple& from);
  AddPathCapabilityTuple(AddPathCapabilityTuple&& from) noexcept
    : AddPathCapabilityTuple() {
    *this = ::std::move(from);
  }

  inline AddPathCapabilityTuple& operator=(const AddPathCapabilityTuple& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddPathCapabilityTuple& operator=(AddPathCapabilityTuple&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AddPathCapabilityTuple& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddPathCapabilityTuple* internal_default_instance() {
    return reinterpret_cast<const AddPathCapabilityTuple*>(
               &_AddPathCapabilityTuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AddPathCapabilityTuple& a, AddPathCapabilityTuple& b) {
    a.Swap(&b);
  }
  inline void Swap(AddPathCapabilityTuple* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddPathCapabilityTuple* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddPathCapabilityTuple* New() const final {
    return CreateMaybeMessage<AddPathCapabilityTuple>(nullptr);
  }

  AddPathCapabilityTuple* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddPathCapabilityTuple>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AddPathCapabilityTuple& from);
  void MergeFrom(const AddPathCapabilityTuple& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddPathCapabilityTuple* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.AddPathCapabilityTuple";
  }
  protected:
  explicit AddPathCapabilityTuple(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AddPathCapabilityTuple_Mode Mode;
  static constexpr Mode NONE =
    AddPathCapabilityTuple_Mode_NONE;
  static constexpr Mode RECEIVE =
    AddPathCapabilityTuple_Mode_RECEIVE;
  static constexpr Mode SEND =
    AddPathCapabilityTuple_Mode_SEND;
  static constexpr Mode BOTH =
    AddPathCapabilityTuple_Mode_BOTH;
  static inline bool Mode_IsValid(int value) {
    return AddPathCapabilityTuple_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN =
    AddPathCapabilityTuple_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX =
    AddPathCapabilityTuple_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE =
    AddPathCapabilityTuple_Mode_Mode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Mode_descriptor() {
    return AddPathCapabilityTuple_Mode_descriptor();
  }
  template<typename T>
  static inline const std::string& Mode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Mode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Mode_Name.");
    return AddPathCapabilityTuple_Mode_Name(enum_t_value);
  }
  static inline bool Mode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Mode* value) {
    return AddPathCapabilityTuple_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFamilyFieldNumber = 1,
    kModeFieldNumber = 2,
  };
  // .apipb.Family family = 1;
  bool has_family() const;
  private:
  bool _internal_has_family() const;
  public:
  void clear_family();
  const ::apipb::Family& family() const;
  ::apipb::Family* release_family();
  ::apipb::Family* mutable_family();
  void set_allocated_family(::apipb::Family* family);
  private:
  const ::apipb::Family& _internal_family() const;
  ::apipb::Family* _internal_mutable_family();
  public:
  void unsafe_arena_set_allocated_family(
      ::apipb::Family* family);
  ::apipb::Family* unsafe_arena_release_family();

  // .apipb.AddPathCapabilityTuple.Mode mode = 2;
  void clear_mode();
  ::apipb::AddPathCapabilityTuple_Mode mode() const;
  void set_mode(::apipb::AddPathCapabilityTuple_Mode value);
  private:
  ::apipb::AddPathCapabilityTuple_Mode _internal_mode() const;
  void _internal_set_mode(::apipb::AddPathCapabilityTuple_Mode value);
  public:

  // @@protoc_insertion_point(class_scope:apipb.AddPathCapabilityTuple)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::apipb::Family* family_;
  int mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// -------------------------------------------------------------------

class AddPathCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.AddPathCapability) */ {
 public:
  inline AddPathCapability() : AddPathCapability(nullptr) {}
  virtual ~AddPathCapability();

  AddPathCapability(const AddPathCapability& from);
  AddPathCapability(AddPathCapability&& from) noexcept
    : AddPathCapability() {
    *this = ::std::move(from);
  }

  inline AddPathCapability& operator=(const AddPathCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddPathCapability& operator=(AddPathCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AddPathCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddPathCapability* internal_default_instance() {
    return reinterpret_cast<const AddPathCapability*>(
               &_AddPathCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AddPathCapability& a, AddPathCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(AddPathCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddPathCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddPathCapability* New() const final {
    return CreateMaybeMessage<AddPathCapability>(nullptr);
  }

  AddPathCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddPathCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AddPathCapability& from);
  void MergeFrom(const AddPathCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddPathCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.AddPathCapability";
  }
  protected:
  explicit AddPathCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTuplesFieldNumber = 1,
  };
  // repeated .apipb.AddPathCapabilityTuple tuples = 1;
  int tuples_size() const;
  private:
  int _internal_tuples_size() const;
  public:
  void clear_tuples();
  ::apipb::AddPathCapabilityTuple* mutable_tuples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::AddPathCapabilityTuple >*
      mutable_tuples();
  private:
  const ::apipb::AddPathCapabilityTuple& _internal_tuples(int index) const;
  ::apipb::AddPathCapabilityTuple* _internal_add_tuples();
  public:
  const ::apipb::AddPathCapabilityTuple& tuples(int index) const;
  ::apipb::AddPathCapabilityTuple* add_tuples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::AddPathCapabilityTuple >&
      tuples() const;

  // @@protoc_insertion_point(class_scope:apipb.AddPathCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::AddPathCapabilityTuple > tuples_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// -------------------------------------------------------------------

class EnhancedRouteRefreshCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.EnhancedRouteRefreshCapability) */ {
 public:
  inline EnhancedRouteRefreshCapability() : EnhancedRouteRefreshCapability(nullptr) {}
  virtual ~EnhancedRouteRefreshCapability();

  EnhancedRouteRefreshCapability(const EnhancedRouteRefreshCapability& from);
  EnhancedRouteRefreshCapability(EnhancedRouteRefreshCapability&& from) noexcept
    : EnhancedRouteRefreshCapability() {
    *this = ::std::move(from);
  }

  inline EnhancedRouteRefreshCapability& operator=(const EnhancedRouteRefreshCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnhancedRouteRefreshCapability& operator=(EnhancedRouteRefreshCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EnhancedRouteRefreshCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnhancedRouteRefreshCapability* internal_default_instance() {
    return reinterpret_cast<const EnhancedRouteRefreshCapability*>(
               &_EnhancedRouteRefreshCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EnhancedRouteRefreshCapability& a, EnhancedRouteRefreshCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(EnhancedRouteRefreshCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnhancedRouteRefreshCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EnhancedRouteRefreshCapability* New() const final {
    return CreateMaybeMessage<EnhancedRouteRefreshCapability>(nullptr);
  }

  EnhancedRouteRefreshCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EnhancedRouteRefreshCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EnhancedRouteRefreshCapability& from);
  void MergeFrom(const EnhancedRouteRefreshCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EnhancedRouteRefreshCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.EnhancedRouteRefreshCapability";
  }
  protected:
  explicit EnhancedRouteRefreshCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apipb.EnhancedRouteRefreshCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// -------------------------------------------------------------------

class LongLivedGracefulRestartCapabilityTuple PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.LongLivedGracefulRestartCapabilityTuple) */ {
 public:
  inline LongLivedGracefulRestartCapabilityTuple() : LongLivedGracefulRestartCapabilityTuple(nullptr) {}
  virtual ~LongLivedGracefulRestartCapabilityTuple();

  LongLivedGracefulRestartCapabilityTuple(const LongLivedGracefulRestartCapabilityTuple& from);
  LongLivedGracefulRestartCapabilityTuple(LongLivedGracefulRestartCapabilityTuple&& from) noexcept
    : LongLivedGracefulRestartCapabilityTuple() {
    *this = ::std::move(from);
  }

  inline LongLivedGracefulRestartCapabilityTuple& operator=(const LongLivedGracefulRestartCapabilityTuple& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongLivedGracefulRestartCapabilityTuple& operator=(LongLivedGracefulRestartCapabilityTuple&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LongLivedGracefulRestartCapabilityTuple& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LongLivedGracefulRestartCapabilityTuple* internal_default_instance() {
    return reinterpret_cast<const LongLivedGracefulRestartCapabilityTuple*>(
               &_LongLivedGracefulRestartCapabilityTuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LongLivedGracefulRestartCapabilityTuple& a, LongLivedGracefulRestartCapabilityTuple& b) {
    a.Swap(&b);
  }
  inline void Swap(LongLivedGracefulRestartCapabilityTuple* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongLivedGracefulRestartCapabilityTuple* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LongLivedGracefulRestartCapabilityTuple* New() const final {
    return CreateMaybeMessage<LongLivedGracefulRestartCapabilityTuple>(nullptr);
  }

  LongLivedGracefulRestartCapabilityTuple* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LongLivedGracefulRestartCapabilityTuple>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LongLivedGracefulRestartCapabilityTuple& from);
  void MergeFrom(const LongLivedGracefulRestartCapabilityTuple& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongLivedGracefulRestartCapabilityTuple* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.LongLivedGracefulRestartCapabilityTuple";
  }
  protected:
  explicit LongLivedGracefulRestartCapabilityTuple(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFamilyFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // .apipb.Family family = 1;
  bool has_family() const;
  private:
  bool _internal_has_family() const;
  public:
  void clear_family();
  const ::apipb::Family& family() const;
  ::apipb::Family* release_family();
  ::apipb::Family* mutable_family();
  void set_allocated_family(::apipb::Family* family);
  private:
  const ::apipb::Family& _internal_family() const;
  ::apipb::Family* _internal_mutable_family();
  public:
  void unsafe_arena_set_allocated_family(
      ::apipb::Family* family);
  ::apipb::Family* unsafe_arena_release_family();

  // uint32 flags = 2;
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint32 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_flags() const;
  void _internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 time = 3;
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::uint32 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:apipb.LongLivedGracefulRestartCapabilityTuple)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::apipb::Family* family_;
  ::PROTOBUF_NAMESPACE_ID::uint32 flags_;
  ::PROTOBUF_NAMESPACE_ID::uint32 time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// -------------------------------------------------------------------

class LongLivedGracefulRestartCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.LongLivedGracefulRestartCapability) */ {
 public:
  inline LongLivedGracefulRestartCapability() : LongLivedGracefulRestartCapability(nullptr) {}
  virtual ~LongLivedGracefulRestartCapability();

  LongLivedGracefulRestartCapability(const LongLivedGracefulRestartCapability& from);
  LongLivedGracefulRestartCapability(LongLivedGracefulRestartCapability&& from) noexcept
    : LongLivedGracefulRestartCapability() {
    *this = ::std::move(from);
  }

  inline LongLivedGracefulRestartCapability& operator=(const LongLivedGracefulRestartCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongLivedGracefulRestartCapability& operator=(LongLivedGracefulRestartCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LongLivedGracefulRestartCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LongLivedGracefulRestartCapability* internal_default_instance() {
    return reinterpret_cast<const LongLivedGracefulRestartCapability*>(
               &_LongLivedGracefulRestartCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LongLivedGracefulRestartCapability& a, LongLivedGracefulRestartCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(LongLivedGracefulRestartCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LongLivedGracefulRestartCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LongLivedGracefulRestartCapability* New() const final {
    return CreateMaybeMessage<LongLivedGracefulRestartCapability>(nullptr);
  }

  LongLivedGracefulRestartCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LongLivedGracefulRestartCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LongLivedGracefulRestartCapability& from);
  void MergeFrom(const LongLivedGracefulRestartCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongLivedGracefulRestartCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.LongLivedGracefulRestartCapability";
  }
  protected:
  explicit LongLivedGracefulRestartCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTuplesFieldNumber = 1,
  };
  // repeated .apipb.LongLivedGracefulRestartCapabilityTuple tuples = 1;
  int tuples_size() const;
  private:
  int _internal_tuples_size() const;
  public:
  void clear_tuples();
  ::apipb::LongLivedGracefulRestartCapabilityTuple* mutable_tuples(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::LongLivedGracefulRestartCapabilityTuple >*
      mutable_tuples();
  private:
  const ::apipb::LongLivedGracefulRestartCapabilityTuple& _internal_tuples(int index) const;
  ::apipb::LongLivedGracefulRestartCapabilityTuple* _internal_add_tuples();
  public:
  const ::apipb::LongLivedGracefulRestartCapabilityTuple& tuples(int index) const;
  ::apipb::LongLivedGracefulRestartCapabilityTuple* add_tuples();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::LongLivedGracefulRestartCapabilityTuple >&
      tuples() const;

  // @@protoc_insertion_point(class_scope:apipb.LongLivedGracefulRestartCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::LongLivedGracefulRestartCapabilityTuple > tuples_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// -------------------------------------------------------------------

class RouteRefreshCiscoCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.RouteRefreshCiscoCapability) */ {
 public:
  inline RouteRefreshCiscoCapability() : RouteRefreshCiscoCapability(nullptr) {}
  virtual ~RouteRefreshCiscoCapability();

  RouteRefreshCiscoCapability(const RouteRefreshCiscoCapability& from);
  RouteRefreshCiscoCapability(RouteRefreshCiscoCapability&& from) noexcept
    : RouteRefreshCiscoCapability() {
    *this = ::std::move(from);
  }

  inline RouteRefreshCiscoCapability& operator=(const RouteRefreshCiscoCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteRefreshCiscoCapability& operator=(RouteRefreshCiscoCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RouteRefreshCiscoCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteRefreshCiscoCapability* internal_default_instance() {
    return reinterpret_cast<const RouteRefreshCiscoCapability*>(
               &_RouteRefreshCiscoCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RouteRefreshCiscoCapability& a, RouteRefreshCiscoCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteRefreshCiscoCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteRefreshCiscoCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RouteRefreshCiscoCapability* New() const final {
    return CreateMaybeMessage<RouteRefreshCiscoCapability>(nullptr);
  }

  RouteRefreshCiscoCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RouteRefreshCiscoCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RouteRefreshCiscoCapability& from);
  void MergeFrom(const RouteRefreshCiscoCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteRefreshCiscoCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.RouteRefreshCiscoCapability";
  }
  protected:
  explicit RouteRefreshCiscoCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apipb.RouteRefreshCiscoCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// -------------------------------------------------------------------

class FqdnCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.FqdnCapability) */ {
 public:
  inline FqdnCapability() : FqdnCapability(nullptr) {}
  virtual ~FqdnCapability();

  FqdnCapability(const FqdnCapability& from);
  FqdnCapability(FqdnCapability&& from) noexcept
    : FqdnCapability() {
    *this = ::std::move(from);
  }

  inline FqdnCapability& operator=(const FqdnCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline FqdnCapability& operator=(FqdnCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FqdnCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FqdnCapability* internal_default_instance() {
    return reinterpret_cast<const FqdnCapability*>(
               &_FqdnCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(FqdnCapability& a, FqdnCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(FqdnCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FqdnCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FqdnCapability* New() const final {
    return CreateMaybeMessage<FqdnCapability>(nullptr);
  }

  FqdnCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FqdnCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FqdnCapability& from);
  void MergeFrom(const FqdnCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FqdnCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.FqdnCapability";
  }
  protected:
  explicit FqdnCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostNameFieldNumber = 1,
    kDomainNameFieldNumber = 2,
  };
  // string host_name = 1;
  void clear_host_name();
  const std::string& host_name() const;
  void set_host_name(const std::string& value);
  void set_host_name(std::string&& value);
  void set_host_name(const char* value);
  void set_host_name(const char* value, size_t size);
  std::string* mutable_host_name();
  std::string* release_host_name();
  void set_allocated_host_name(std::string* host_name);
  private:
  const std::string& _internal_host_name() const;
  void _internal_set_host_name(const std::string& value);
  std::string* _internal_mutable_host_name();
  public:

  // string domain_name = 2;
  void clear_domain_name();
  const std::string& domain_name() const;
  void set_domain_name(const std::string& value);
  void set_domain_name(std::string&& value);
  void set_domain_name(const char* value);
  void set_domain_name(const char* value, size_t size);
  std::string* mutable_domain_name();
  std::string* release_domain_name();
  void set_allocated_domain_name(std::string* domain_name);
  private:
  const std::string& _internal_domain_name() const;
  void _internal_set_domain_name(const std::string& value);
  std::string* _internal_mutable_domain_name();
  public:

  // @@protoc_insertion_point(class_scope:apipb.FqdnCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// -------------------------------------------------------------------

class SoftwareVersionCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.SoftwareVersionCapability) */ {
 public:
  inline SoftwareVersionCapability() : SoftwareVersionCapability(nullptr) {}
  virtual ~SoftwareVersionCapability();

  SoftwareVersionCapability(const SoftwareVersionCapability& from);
  SoftwareVersionCapability(SoftwareVersionCapability&& from) noexcept
    : SoftwareVersionCapability() {
    *this = ::std::move(from);
  }

  inline SoftwareVersionCapability& operator=(const SoftwareVersionCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoftwareVersionCapability& operator=(SoftwareVersionCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SoftwareVersionCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SoftwareVersionCapability* internal_default_instance() {
    return reinterpret_cast<const SoftwareVersionCapability*>(
               &_SoftwareVersionCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SoftwareVersionCapability& a, SoftwareVersionCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(SoftwareVersionCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoftwareVersionCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SoftwareVersionCapability* New() const final {
    return CreateMaybeMessage<SoftwareVersionCapability>(nullptr);
  }

  SoftwareVersionCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SoftwareVersionCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SoftwareVersionCapability& from);
  void MergeFrom(const SoftwareVersionCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SoftwareVersionCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.SoftwareVersionCapability";
  }
  protected:
  explicit SoftwareVersionCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoftwareVersionFieldNumber = 1,
  };
  // string software_version = 1;
  void clear_software_version();
  const std::string& software_version() const;
  void set_software_version(const std::string& value);
  void set_software_version(std::string&& value);
  void set_software_version(const char* value);
  void set_software_version(const char* value, size_t size);
  std::string* mutable_software_version();
  std::string* release_software_version();
  void set_allocated_software_version(std::string* software_version);
  private:
  const std::string& _internal_software_version() const;
  void _internal_set_software_version(const std::string& value);
  std::string* _internal_mutable_software_version();
  public:

  // @@protoc_insertion_point(class_scope:apipb.SoftwareVersionCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr software_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// -------------------------------------------------------------------

class UnknownCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:apipb.UnknownCapability) */ {
 public:
  inline UnknownCapability() : UnknownCapability(nullptr) {}
  virtual ~UnknownCapability();

  UnknownCapability(const UnknownCapability& from);
  UnknownCapability(UnknownCapability&& from) noexcept
    : UnknownCapability() {
    *this = ::std::move(from);
  }

  inline UnknownCapability& operator=(const UnknownCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnknownCapability& operator=(UnknownCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UnknownCapability& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnknownCapability* internal_default_instance() {
    return reinterpret_cast<const UnknownCapability*>(
               &_UnknownCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UnknownCapability& a, UnknownCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(UnknownCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnknownCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnknownCapability* New() const final {
    return CreateMaybeMessage<UnknownCapability>(nullptr);
  }

  UnknownCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnknownCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UnknownCapability& from);
  void MergeFrom(const UnknownCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnknownCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "apipb.UnknownCapability";
  }
  protected:
  explicit UnknownCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_capability_2eproto);
    return ::descriptor_table_capability_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // bytes value = 2;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // uint32 code = 1;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:apipb.UnknownCapability)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::uint32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_capability_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MultiProtocolCapability

// .apipb.Family family = 1;
inline bool MultiProtocolCapability::_internal_has_family() const {
  return this != internal_default_instance() && family_ != nullptr;
}
inline bool MultiProtocolCapability::has_family() const {
  return _internal_has_family();
}
inline const ::apipb::Family& MultiProtocolCapability::_internal_family() const {
  const ::apipb::Family* p = family_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apipb::Family*>(
      &::apipb::_Family_default_instance_);
}
inline const ::apipb::Family& MultiProtocolCapability::family() const {
  // @@protoc_insertion_point(field_get:apipb.MultiProtocolCapability.family)
  return _internal_family();
}
inline void MultiProtocolCapability::unsafe_arena_set_allocated_family(
    ::apipb::Family* family) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(family_);
  }
  family_ = family;
  if (family) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apipb.MultiProtocolCapability.family)
}
inline ::apipb::Family* MultiProtocolCapability::release_family() {
  
  ::apipb::Family* temp = family_;
  family_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apipb::Family* MultiProtocolCapability::unsafe_arena_release_family() {
  // @@protoc_insertion_point(field_release:apipb.MultiProtocolCapability.family)
  
  ::apipb::Family* temp = family_;
  family_ = nullptr;
  return temp;
}
inline ::apipb::Family* MultiProtocolCapability::_internal_mutable_family() {
  
  if (family_ == nullptr) {
    auto* p = CreateMaybeMessage<::apipb::Family>(GetArena());
    family_ = p;
  }
  return family_;
}
inline ::apipb::Family* MultiProtocolCapability::mutable_family() {
  // @@protoc_insertion_point(field_mutable:apipb.MultiProtocolCapability.family)
  return _internal_mutable_family();
}
inline void MultiProtocolCapability::set_allocated_family(::apipb::Family* family) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(family_);
  }
  if (family) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(family)->GetArena();
    if (message_arena != submessage_arena) {
      family = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, family, submessage_arena);
    }
    
  } else {
    
  }
  family_ = family;
  // @@protoc_insertion_point(field_set_allocated:apipb.MultiProtocolCapability.family)
}

// -------------------------------------------------------------------

// RouteRefreshCapability

// -------------------------------------------------------------------

// CarryingLabelInfoCapability

// -------------------------------------------------------------------

// ExtendedNexthopCapabilityTuple

// .apipb.Family nlri_family = 1;
inline bool ExtendedNexthopCapabilityTuple::_internal_has_nlri_family() const {
  return this != internal_default_instance() && nlri_family_ != nullptr;
}
inline bool ExtendedNexthopCapabilityTuple::has_nlri_family() const {
  return _internal_has_nlri_family();
}
inline const ::apipb::Family& ExtendedNexthopCapabilityTuple::_internal_nlri_family() const {
  const ::apipb::Family* p = nlri_family_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apipb::Family*>(
      &::apipb::_Family_default_instance_);
}
inline const ::apipb::Family& ExtendedNexthopCapabilityTuple::nlri_family() const {
  // @@protoc_insertion_point(field_get:apipb.ExtendedNexthopCapabilityTuple.nlri_family)
  return _internal_nlri_family();
}
inline void ExtendedNexthopCapabilityTuple::unsafe_arena_set_allocated_nlri_family(
    ::apipb::Family* nlri_family) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nlri_family_);
  }
  nlri_family_ = nlri_family;
  if (nlri_family) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apipb.ExtendedNexthopCapabilityTuple.nlri_family)
}
inline ::apipb::Family* ExtendedNexthopCapabilityTuple::release_nlri_family() {
  
  ::apipb::Family* temp = nlri_family_;
  nlri_family_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apipb::Family* ExtendedNexthopCapabilityTuple::unsafe_arena_release_nlri_family() {
  // @@protoc_insertion_point(field_release:apipb.ExtendedNexthopCapabilityTuple.nlri_family)
  
  ::apipb::Family* temp = nlri_family_;
  nlri_family_ = nullptr;
  return temp;
}
inline ::apipb::Family* ExtendedNexthopCapabilityTuple::_internal_mutable_nlri_family() {
  
  if (nlri_family_ == nullptr) {
    auto* p = CreateMaybeMessage<::apipb::Family>(GetArena());
    nlri_family_ = p;
  }
  return nlri_family_;
}
inline ::apipb::Family* ExtendedNexthopCapabilityTuple::mutable_nlri_family() {
  // @@protoc_insertion_point(field_mutable:apipb.ExtendedNexthopCapabilityTuple.nlri_family)
  return _internal_mutable_nlri_family();
}
inline void ExtendedNexthopCapabilityTuple::set_allocated_nlri_family(::apipb::Family* nlri_family) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nlri_family_);
  }
  if (nlri_family) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nlri_family)->GetArena();
    if (message_arena != submessage_arena) {
      nlri_family = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nlri_family, submessage_arena);
    }
    
  } else {
    
  }
  nlri_family_ = nlri_family;
  // @@protoc_insertion_point(field_set_allocated:apipb.ExtendedNexthopCapabilityTuple.nlri_family)
}

// .apipb.Family nexthop_family = 2;
inline bool ExtendedNexthopCapabilityTuple::_internal_has_nexthop_family() const {
  return this != internal_default_instance() && nexthop_family_ != nullptr;
}
inline bool ExtendedNexthopCapabilityTuple::has_nexthop_family() const {
  return _internal_has_nexthop_family();
}
inline const ::apipb::Family& ExtendedNexthopCapabilityTuple::_internal_nexthop_family() const {
  const ::apipb::Family* p = nexthop_family_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apipb::Family*>(
      &::apipb::_Family_default_instance_);
}
inline const ::apipb::Family& ExtendedNexthopCapabilityTuple::nexthop_family() const {
  // @@protoc_insertion_point(field_get:apipb.ExtendedNexthopCapabilityTuple.nexthop_family)
  return _internal_nexthop_family();
}
inline void ExtendedNexthopCapabilityTuple::unsafe_arena_set_allocated_nexthop_family(
    ::apipb::Family* nexthop_family) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthop_family_);
  }
  nexthop_family_ = nexthop_family;
  if (nexthop_family) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apipb.ExtendedNexthopCapabilityTuple.nexthop_family)
}
inline ::apipb::Family* ExtendedNexthopCapabilityTuple::release_nexthop_family() {
  
  ::apipb::Family* temp = nexthop_family_;
  nexthop_family_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apipb::Family* ExtendedNexthopCapabilityTuple::unsafe_arena_release_nexthop_family() {
  // @@protoc_insertion_point(field_release:apipb.ExtendedNexthopCapabilityTuple.nexthop_family)
  
  ::apipb::Family* temp = nexthop_family_;
  nexthop_family_ = nullptr;
  return temp;
}
inline ::apipb::Family* ExtendedNexthopCapabilityTuple::_internal_mutable_nexthop_family() {
  
  if (nexthop_family_ == nullptr) {
    auto* p = CreateMaybeMessage<::apipb::Family>(GetArena());
    nexthop_family_ = p;
  }
  return nexthop_family_;
}
inline ::apipb::Family* ExtendedNexthopCapabilityTuple::mutable_nexthop_family() {
  // @@protoc_insertion_point(field_mutable:apipb.ExtendedNexthopCapabilityTuple.nexthop_family)
  return _internal_mutable_nexthop_family();
}
inline void ExtendedNexthopCapabilityTuple::set_allocated_nexthop_family(::apipb::Family* nexthop_family) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthop_family_);
  }
  if (nexthop_family) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nexthop_family)->GetArena();
    if (message_arena != submessage_arena) {
      nexthop_family = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nexthop_family, submessage_arena);
    }
    
  } else {
    
  }
  nexthop_family_ = nexthop_family;
  // @@protoc_insertion_point(field_set_allocated:apipb.ExtendedNexthopCapabilityTuple.nexthop_family)
}

// -------------------------------------------------------------------

// ExtendedNexthopCapability

// repeated .apipb.ExtendedNexthopCapabilityTuple tuples = 1;
inline int ExtendedNexthopCapability::_internal_tuples_size() const {
  return tuples_.size();
}
inline int ExtendedNexthopCapability::tuples_size() const {
  return _internal_tuples_size();
}
inline void ExtendedNexthopCapability::clear_tuples() {
  tuples_.Clear();
}
inline ::apipb::ExtendedNexthopCapabilityTuple* ExtendedNexthopCapability::mutable_tuples(int index) {
  // @@protoc_insertion_point(field_mutable:apipb.ExtendedNexthopCapability.tuples)
  return tuples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::ExtendedNexthopCapabilityTuple >*
ExtendedNexthopCapability::mutable_tuples() {
  // @@protoc_insertion_point(field_mutable_list:apipb.ExtendedNexthopCapability.tuples)
  return &tuples_;
}
inline const ::apipb::ExtendedNexthopCapabilityTuple& ExtendedNexthopCapability::_internal_tuples(int index) const {
  return tuples_.Get(index);
}
inline const ::apipb::ExtendedNexthopCapabilityTuple& ExtendedNexthopCapability::tuples(int index) const {
  // @@protoc_insertion_point(field_get:apipb.ExtendedNexthopCapability.tuples)
  return _internal_tuples(index);
}
inline ::apipb::ExtendedNexthopCapabilityTuple* ExtendedNexthopCapability::_internal_add_tuples() {
  return tuples_.Add();
}
inline ::apipb::ExtendedNexthopCapabilityTuple* ExtendedNexthopCapability::add_tuples() {
  // @@protoc_insertion_point(field_add:apipb.ExtendedNexthopCapability.tuples)
  return _internal_add_tuples();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::ExtendedNexthopCapabilityTuple >&
ExtendedNexthopCapability::tuples() const {
  // @@protoc_insertion_point(field_list:apipb.ExtendedNexthopCapability.tuples)
  return tuples_;
}

// -------------------------------------------------------------------

// GracefulRestartCapabilityTuple

// .apipb.Family family = 1;
inline bool GracefulRestartCapabilityTuple::_internal_has_family() const {
  return this != internal_default_instance() && family_ != nullptr;
}
inline bool GracefulRestartCapabilityTuple::has_family() const {
  return _internal_has_family();
}
inline const ::apipb::Family& GracefulRestartCapabilityTuple::_internal_family() const {
  const ::apipb::Family* p = family_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apipb::Family*>(
      &::apipb::_Family_default_instance_);
}
inline const ::apipb::Family& GracefulRestartCapabilityTuple::family() const {
  // @@protoc_insertion_point(field_get:apipb.GracefulRestartCapabilityTuple.family)
  return _internal_family();
}
inline void GracefulRestartCapabilityTuple::unsafe_arena_set_allocated_family(
    ::apipb::Family* family) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(family_);
  }
  family_ = family;
  if (family) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apipb.GracefulRestartCapabilityTuple.family)
}
inline ::apipb::Family* GracefulRestartCapabilityTuple::release_family() {
  
  ::apipb::Family* temp = family_;
  family_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apipb::Family* GracefulRestartCapabilityTuple::unsafe_arena_release_family() {
  // @@protoc_insertion_point(field_release:apipb.GracefulRestartCapabilityTuple.family)
  
  ::apipb::Family* temp = family_;
  family_ = nullptr;
  return temp;
}
inline ::apipb::Family* GracefulRestartCapabilityTuple::_internal_mutable_family() {
  
  if (family_ == nullptr) {
    auto* p = CreateMaybeMessage<::apipb::Family>(GetArena());
    family_ = p;
  }
  return family_;
}
inline ::apipb::Family* GracefulRestartCapabilityTuple::mutable_family() {
  // @@protoc_insertion_point(field_mutable:apipb.GracefulRestartCapabilityTuple.family)
  return _internal_mutable_family();
}
inline void GracefulRestartCapabilityTuple::set_allocated_family(::apipb::Family* family) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(family_);
  }
  if (family) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(family)->GetArena();
    if (message_arena != submessage_arena) {
      family = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, family, submessage_arena);
    }
    
  } else {
    
  }
  family_ = family;
  // @@protoc_insertion_point(field_set_allocated:apipb.GracefulRestartCapabilityTuple.family)
}

// uint32 flags = 2;
inline void GracefulRestartCapabilityTuple::clear_flags() {
  flags_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GracefulRestartCapabilityTuple::_internal_flags() const {
  return flags_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GracefulRestartCapabilityTuple::flags() const {
  // @@protoc_insertion_point(field_get:apipb.GracefulRestartCapabilityTuple.flags)
  return _internal_flags();
}
inline void GracefulRestartCapabilityTuple::_internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  flags_ = value;
}
inline void GracefulRestartCapabilityTuple::set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:apipb.GracefulRestartCapabilityTuple.flags)
}

// -------------------------------------------------------------------

// GracefulRestartCapability

// uint32 flags = 1;
inline void GracefulRestartCapability::clear_flags() {
  flags_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GracefulRestartCapability::_internal_flags() const {
  return flags_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GracefulRestartCapability::flags() const {
  // @@protoc_insertion_point(field_get:apipb.GracefulRestartCapability.flags)
  return _internal_flags();
}
inline void GracefulRestartCapability::_internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  flags_ = value;
}
inline void GracefulRestartCapability::set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:apipb.GracefulRestartCapability.flags)
}

// uint32 time = 2;
inline void GracefulRestartCapability::clear_time() {
  time_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GracefulRestartCapability::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GracefulRestartCapability::time() const {
  // @@protoc_insertion_point(field_get:apipb.GracefulRestartCapability.time)
  return _internal_time();
}
inline void GracefulRestartCapability::_internal_set_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  time_ = value;
}
inline void GracefulRestartCapability::set_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:apipb.GracefulRestartCapability.time)
}

// repeated .apipb.GracefulRestartCapabilityTuple tuples = 3;
inline int GracefulRestartCapability::_internal_tuples_size() const {
  return tuples_.size();
}
inline int GracefulRestartCapability::tuples_size() const {
  return _internal_tuples_size();
}
inline void GracefulRestartCapability::clear_tuples() {
  tuples_.Clear();
}
inline ::apipb::GracefulRestartCapabilityTuple* GracefulRestartCapability::mutable_tuples(int index) {
  // @@protoc_insertion_point(field_mutable:apipb.GracefulRestartCapability.tuples)
  return tuples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::GracefulRestartCapabilityTuple >*
GracefulRestartCapability::mutable_tuples() {
  // @@protoc_insertion_point(field_mutable_list:apipb.GracefulRestartCapability.tuples)
  return &tuples_;
}
inline const ::apipb::GracefulRestartCapabilityTuple& GracefulRestartCapability::_internal_tuples(int index) const {
  return tuples_.Get(index);
}
inline const ::apipb::GracefulRestartCapabilityTuple& GracefulRestartCapability::tuples(int index) const {
  // @@protoc_insertion_point(field_get:apipb.GracefulRestartCapability.tuples)
  return _internal_tuples(index);
}
inline ::apipb::GracefulRestartCapabilityTuple* GracefulRestartCapability::_internal_add_tuples() {
  return tuples_.Add();
}
inline ::apipb::GracefulRestartCapabilityTuple* GracefulRestartCapability::add_tuples() {
  // @@protoc_insertion_point(field_add:apipb.GracefulRestartCapability.tuples)
  return _internal_add_tuples();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::GracefulRestartCapabilityTuple >&
GracefulRestartCapability::tuples() const {
  // @@protoc_insertion_point(field_list:apipb.GracefulRestartCapability.tuples)
  return tuples_;
}

// -------------------------------------------------------------------

// FourOctetASNCapability

// uint32 asn = 1;
inline void FourOctetASNCapability::clear_asn() {
  asn_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FourOctetASNCapability::_internal_asn() const {
  return asn_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FourOctetASNCapability::asn() const {
  // @@protoc_insertion_point(field_get:apipb.FourOctetASNCapability.asn)
  return _internal_asn();
}
inline void FourOctetASNCapability::_internal_set_asn(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  asn_ = value;
}
inline void FourOctetASNCapability::set_asn(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_asn(value);
  // @@protoc_insertion_point(field_set:apipb.FourOctetASNCapability.asn)
}

// -------------------------------------------------------------------

// AddPathCapabilityTuple

// .apipb.Family family = 1;
inline bool AddPathCapabilityTuple::_internal_has_family() const {
  return this != internal_default_instance() && family_ != nullptr;
}
inline bool AddPathCapabilityTuple::has_family() const {
  return _internal_has_family();
}
inline const ::apipb::Family& AddPathCapabilityTuple::_internal_family() const {
  const ::apipb::Family* p = family_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apipb::Family*>(
      &::apipb::_Family_default_instance_);
}
inline const ::apipb::Family& AddPathCapabilityTuple::family() const {
  // @@protoc_insertion_point(field_get:apipb.AddPathCapabilityTuple.family)
  return _internal_family();
}
inline void AddPathCapabilityTuple::unsafe_arena_set_allocated_family(
    ::apipb::Family* family) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(family_);
  }
  family_ = family;
  if (family) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apipb.AddPathCapabilityTuple.family)
}
inline ::apipb::Family* AddPathCapabilityTuple::release_family() {
  
  ::apipb::Family* temp = family_;
  family_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apipb::Family* AddPathCapabilityTuple::unsafe_arena_release_family() {
  // @@protoc_insertion_point(field_release:apipb.AddPathCapabilityTuple.family)
  
  ::apipb::Family* temp = family_;
  family_ = nullptr;
  return temp;
}
inline ::apipb::Family* AddPathCapabilityTuple::_internal_mutable_family() {
  
  if (family_ == nullptr) {
    auto* p = CreateMaybeMessage<::apipb::Family>(GetArena());
    family_ = p;
  }
  return family_;
}
inline ::apipb::Family* AddPathCapabilityTuple::mutable_family() {
  // @@protoc_insertion_point(field_mutable:apipb.AddPathCapabilityTuple.family)
  return _internal_mutable_family();
}
inline void AddPathCapabilityTuple::set_allocated_family(::apipb::Family* family) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(family_);
  }
  if (family) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(family)->GetArena();
    if (message_arena != submessage_arena) {
      family = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, family, submessage_arena);
    }
    
  } else {
    
  }
  family_ = family;
  // @@protoc_insertion_point(field_set_allocated:apipb.AddPathCapabilityTuple.family)
}

// .apipb.AddPathCapabilityTuple.Mode mode = 2;
inline void AddPathCapabilityTuple::clear_mode() {
  mode_ = 0;
}
inline ::apipb::AddPathCapabilityTuple_Mode AddPathCapabilityTuple::_internal_mode() const {
  return static_cast< ::apipb::AddPathCapabilityTuple_Mode >(mode_);
}
inline ::apipb::AddPathCapabilityTuple_Mode AddPathCapabilityTuple::mode() const {
  // @@protoc_insertion_point(field_get:apipb.AddPathCapabilityTuple.mode)
  return _internal_mode();
}
inline void AddPathCapabilityTuple::_internal_set_mode(::apipb::AddPathCapabilityTuple_Mode value) {
  
  mode_ = value;
}
inline void AddPathCapabilityTuple::set_mode(::apipb::AddPathCapabilityTuple_Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:apipb.AddPathCapabilityTuple.mode)
}

// -------------------------------------------------------------------

// AddPathCapability

// repeated .apipb.AddPathCapabilityTuple tuples = 1;
inline int AddPathCapability::_internal_tuples_size() const {
  return tuples_.size();
}
inline int AddPathCapability::tuples_size() const {
  return _internal_tuples_size();
}
inline void AddPathCapability::clear_tuples() {
  tuples_.Clear();
}
inline ::apipb::AddPathCapabilityTuple* AddPathCapability::mutable_tuples(int index) {
  // @@protoc_insertion_point(field_mutable:apipb.AddPathCapability.tuples)
  return tuples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::AddPathCapabilityTuple >*
AddPathCapability::mutable_tuples() {
  // @@protoc_insertion_point(field_mutable_list:apipb.AddPathCapability.tuples)
  return &tuples_;
}
inline const ::apipb::AddPathCapabilityTuple& AddPathCapability::_internal_tuples(int index) const {
  return tuples_.Get(index);
}
inline const ::apipb::AddPathCapabilityTuple& AddPathCapability::tuples(int index) const {
  // @@protoc_insertion_point(field_get:apipb.AddPathCapability.tuples)
  return _internal_tuples(index);
}
inline ::apipb::AddPathCapabilityTuple* AddPathCapability::_internal_add_tuples() {
  return tuples_.Add();
}
inline ::apipb::AddPathCapabilityTuple* AddPathCapability::add_tuples() {
  // @@protoc_insertion_point(field_add:apipb.AddPathCapability.tuples)
  return _internal_add_tuples();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::AddPathCapabilityTuple >&
AddPathCapability::tuples() const {
  // @@protoc_insertion_point(field_list:apipb.AddPathCapability.tuples)
  return tuples_;
}

// -------------------------------------------------------------------

// EnhancedRouteRefreshCapability

// -------------------------------------------------------------------

// LongLivedGracefulRestartCapabilityTuple

// .apipb.Family family = 1;
inline bool LongLivedGracefulRestartCapabilityTuple::_internal_has_family() const {
  return this != internal_default_instance() && family_ != nullptr;
}
inline bool LongLivedGracefulRestartCapabilityTuple::has_family() const {
  return _internal_has_family();
}
inline const ::apipb::Family& LongLivedGracefulRestartCapabilityTuple::_internal_family() const {
  const ::apipb::Family* p = family_;
  return p != nullptr ? *p : *reinterpret_cast<const ::apipb::Family*>(
      &::apipb::_Family_default_instance_);
}
inline const ::apipb::Family& LongLivedGracefulRestartCapabilityTuple::family() const {
  // @@protoc_insertion_point(field_get:apipb.LongLivedGracefulRestartCapabilityTuple.family)
  return _internal_family();
}
inline void LongLivedGracefulRestartCapabilityTuple::unsafe_arena_set_allocated_family(
    ::apipb::Family* family) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(family_);
  }
  family_ = family;
  if (family) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:apipb.LongLivedGracefulRestartCapabilityTuple.family)
}
inline ::apipb::Family* LongLivedGracefulRestartCapabilityTuple::release_family() {
  
  ::apipb::Family* temp = family_;
  family_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::apipb::Family* LongLivedGracefulRestartCapabilityTuple::unsafe_arena_release_family() {
  // @@protoc_insertion_point(field_release:apipb.LongLivedGracefulRestartCapabilityTuple.family)
  
  ::apipb::Family* temp = family_;
  family_ = nullptr;
  return temp;
}
inline ::apipb::Family* LongLivedGracefulRestartCapabilityTuple::_internal_mutable_family() {
  
  if (family_ == nullptr) {
    auto* p = CreateMaybeMessage<::apipb::Family>(GetArena());
    family_ = p;
  }
  return family_;
}
inline ::apipb::Family* LongLivedGracefulRestartCapabilityTuple::mutable_family() {
  // @@protoc_insertion_point(field_mutable:apipb.LongLivedGracefulRestartCapabilityTuple.family)
  return _internal_mutable_family();
}
inline void LongLivedGracefulRestartCapabilityTuple::set_allocated_family(::apipb::Family* family) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(family_);
  }
  if (family) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(family)->GetArena();
    if (message_arena != submessage_arena) {
      family = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, family, submessage_arena);
    }
    
  } else {
    
  }
  family_ = family;
  // @@protoc_insertion_point(field_set_allocated:apipb.LongLivedGracefulRestartCapabilityTuple.family)
}

// uint32 flags = 2;
inline void LongLivedGracefulRestartCapabilityTuple::clear_flags() {
  flags_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LongLivedGracefulRestartCapabilityTuple::_internal_flags() const {
  return flags_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LongLivedGracefulRestartCapabilityTuple::flags() const {
  // @@protoc_insertion_point(field_get:apipb.LongLivedGracefulRestartCapabilityTuple.flags)
  return _internal_flags();
}
inline void LongLivedGracefulRestartCapabilityTuple::_internal_set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  flags_ = value;
}
inline void LongLivedGracefulRestartCapabilityTuple::set_flags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:apipb.LongLivedGracefulRestartCapabilityTuple.flags)
}

// uint32 time = 3;
inline void LongLivedGracefulRestartCapabilityTuple::clear_time() {
  time_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LongLivedGracefulRestartCapabilityTuple::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 LongLivedGracefulRestartCapabilityTuple::time() const {
  // @@protoc_insertion_point(field_get:apipb.LongLivedGracefulRestartCapabilityTuple.time)
  return _internal_time();
}
inline void LongLivedGracefulRestartCapabilityTuple::_internal_set_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  time_ = value;
}
inline void LongLivedGracefulRestartCapabilityTuple::set_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:apipb.LongLivedGracefulRestartCapabilityTuple.time)
}

// -------------------------------------------------------------------

// LongLivedGracefulRestartCapability

// repeated .apipb.LongLivedGracefulRestartCapabilityTuple tuples = 1;
inline int LongLivedGracefulRestartCapability::_internal_tuples_size() const {
  return tuples_.size();
}
inline int LongLivedGracefulRestartCapability::tuples_size() const {
  return _internal_tuples_size();
}
inline void LongLivedGracefulRestartCapability::clear_tuples() {
  tuples_.Clear();
}
inline ::apipb::LongLivedGracefulRestartCapabilityTuple* LongLivedGracefulRestartCapability::mutable_tuples(int index) {
  // @@protoc_insertion_point(field_mutable:apipb.LongLivedGracefulRestartCapability.tuples)
  return tuples_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::LongLivedGracefulRestartCapabilityTuple >*
LongLivedGracefulRestartCapability::mutable_tuples() {
  // @@protoc_insertion_point(field_mutable_list:apipb.LongLivedGracefulRestartCapability.tuples)
  return &tuples_;
}
inline const ::apipb::LongLivedGracefulRestartCapabilityTuple& LongLivedGracefulRestartCapability::_internal_tuples(int index) const {
  return tuples_.Get(index);
}
inline const ::apipb::LongLivedGracefulRestartCapabilityTuple& LongLivedGracefulRestartCapability::tuples(int index) const {
  // @@protoc_insertion_point(field_get:apipb.LongLivedGracefulRestartCapability.tuples)
  return _internal_tuples(index);
}
inline ::apipb::LongLivedGracefulRestartCapabilityTuple* LongLivedGracefulRestartCapability::_internal_add_tuples() {
  return tuples_.Add();
}
inline ::apipb::LongLivedGracefulRestartCapabilityTuple* LongLivedGracefulRestartCapability::add_tuples() {
  // @@protoc_insertion_point(field_add:apipb.LongLivedGracefulRestartCapability.tuples)
  return _internal_add_tuples();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::apipb::LongLivedGracefulRestartCapabilityTuple >&
LongLivedGracefulRestartCapability::tuples() const {
  // @@protoc_insertion_point(field_list:apipb.LongLivedGracefulRestartCapability.tuples)
  return tuples_;
}

// -------------------------------------------------------------------

// RouteRefreshCiscoCapability

// -------------------------------------------------------------------

// FqdnCapability

// string host_name = 1;
inline void FqdnCapability::clear_host_name() {
  host_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FqdnCapability::host_name() const {
  // @@protoc_insertion_point(field_get:apipb.FqdnCapability.host_name)
  return _internal_host_name();
}
inline void FqdnCapability::set_host_name(const std::string& value) {
  _internal_set_host_name(value);
  // @@protoc_insertion_point(field_set:apipb.FqdnCapability.host_name)
}
inline std::string* FqdnCapability::mutable_host_name() {
  // @@protoc_insertion_point(field_mutable:apipb.FqdnCapability.host_name)
  return _internal_mutable_host_name();
}
inline const std::string& FqdnCapability::_internal_host_name() const {
  return host_name_.Get();
}
inline void FqdnCapability::_internal_set_host_name(const std::string& value) {
  
  host_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FqdnCapability::set_host_name(std::string&& value) {
  
  host_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:apipb.FqdnCapability.host_name)
}
inline void FqdnCapability::set_host_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  host_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:apipb.FqdnCapability.host_name)
}
inline void FqdnCapability::set_host_name(const char* value,
    size_t size) {
  
  host_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:apipb.FqdnCapability.host_name)
}
inline std::string* FqdnCapability::_internal_mutable_host_name() {
  
  return host_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FqdnCapability::release_host_name() {
  // @@protoc_insertion_point(field_release:apipb.FqdnCapability.host_name)
  return host_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FqdnCapability::set_allocated_host_name(std::string* host_name) {
  if (host_name != nullptr) {
    
  } else {
    
  }
  host_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:apipb.FqdnCapability.host_name)
}

// string domain_name = 2;
inline void FqdnCapability::clear_domain_name() {
  domain_name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& FqdnCapability::domain_name() const {
  // @@protoc_insertion_point(field_get:apipb.FqdnCapability.domain_name)
  return _internal_domain_name();
}
inline void FqdnCapability::set_domain_name(const std::string& value) {
  _internal_set_domain_name(value);
  // @@protoc_insertion_point(field_set:apipb.FqdnCapability.domain_name)
}
inline std::string* FqdnCapability::mutable_domain_name() {
  // @@protoc_insertion_point(field_mutable:apipb.FqdnCapability.domain_name)
  return _internal_mutable_domain_name();
}
inline const std::string& FqdnCapability::_internal_domain_name() const {
  return domain_name_.Get();
}
inline void FqdnCapability::_internal_set_domain_name(const std::string& value) {
  
  domain_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void FqdnCapability::set_domain_name(std::string&& value) {
  
  domain_name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:apipb.FqdnCapability.domain_name)
}
inline void FqdnCapability::set_domain_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  domain_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:apipb.FqdnCapability.domain_name)
}
inline void FqdnCapability::set_domain_name(const char* value,
    size_t size) {
  
  domain_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:apipb.FqdnCapability.domain_name)
}
inline std::string* FqdnCapability::_internal_mutable_domain_name() {
  
  return domain_name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* FqdnCapability::release_domain_name() {
  // @@protoc_insertion_point(field_release:apipb.FqdnCapability.domain_name)
  return domain_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void FqdnCapability::set_allocated_domain_name(std::string* domain_name) {
  if (domain_name != nullptr) {
    
  } else {
    
  }
  domain_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain_name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:apipb.FqdnCapability.domain_name)
}

// -------------------------------------------------------------------

// SoftwareVersionCapability

// string software_version = 1;
inline void SoftwareVersionCapability::clear_software_version() {
  software_version_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& SoftwareVersionCapability::software_version() const {
  // @@protoc_insertion_point(field_get:apipb.SoftwareVersionCapability.software_version)
  return _internal_software_version();
}
inline void SoftwareVersionCapability::set_software_version(const std::string& value) {
  _internal_set_software_version(value);
  // @@protoc_insertion_point(field_set:apipb.SoftwareVersionCapability.software_version)
}
inline std::string* SoftwareVersionCapability::mutable_software_version() {
  // @@protoc_insertion_point(field_mutable:apipb.SoftwareVersionCapability.software_version)
  return _internal_mutable_software_version();
}
inline const std::string& SoftwareVersionCapability::_internal_software_version() const {
  return software_version_.Get();
}
inline void SoftwareVersionCapability::_internal_set_software_version(const std::string& value) {
  
  software_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void SoftwareVersionCapability::set_software_version(std::string&& value) {
  
  software_version_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:apipb.SoftwareVersionCapability.software_version)
}
inline void SoftwareVersionCapability::set_software_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  software_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:apipb.SoftwareVersionCapability.software_version)
}
inline void SoftwareVersionCapability::set_software_version(const char* value,
    size_t size) {
  
  software_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:apipb.SoftwareVersionCapability.software_version)
}
inline std::string* SoftwareVersionCapability::_internal_mutable_software_version() {
  
  return software_version_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* SoftwareVersionCapability::release_software_version() {
  // @@protoc_insertion_point(field_release:apipb.SoftwareVersionCapability.software_version)
  return software_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SoftwareVersionCapability::set_allocated_software_version(std::string* software_version) {
  if (software_version != nullptr) {
    
  } else {
    
  }
  software_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), software_version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:apipb.SoftwareVersionCapability.software_version)
}

// -------------------------------------------------------------------

// UnknownCapability

// uint32 code = 1;
inline void UnknownCapability::clear_code() {
  code_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnknownCapability::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 UnknownCapability::code() const {
  // @@protoc_insertion_point(field_get:apipb.UnknownCapability.code)
  return _internal_code();
}
inline void UnknownCapability::_internal_set_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  code_ = value;
}
inline void UnknownCapability::set_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:apipb.UnknownCapability.code)
}

// bytes value = 2;
inline void UnknownCapability::clear_value() {
  value_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& UnknownCapability::value() const {
  // @@protoc_insertion_point(field_get:apipb.UnknownCapability.value)
  return _internal_value();
}
inline void UnknownCapability::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:apipb.UnknownCapability.value)
}
inline std::string* UnknownCapability::mutable_value() {
  // @@protoc_insertion_point(field_mutable:apipb.UnknownCapability.value)
  return _internal_mutable_value();
}
inline const std::string& UnknownCapability::_internal_value() const {
  return value_.Get();
}
inline void UnknownCapability::_internal_set_value(const std::string& value) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UnknownCapability::set_value(std::string&& value) {
  
  value_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:apipb.UnknownCapability.value)
}
inline void UnknownCapability::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:apipb.UnknownCapability.value)
}
inline void UnknownCapability::set_value(const void* value,
    size_t size) {
  
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:apipb.UnknownCapability.value)
}
inline std::string* UnknownCapability::_internal_mutable_value() {
  
  return value_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UnknownCapability::release_value() {
  // @@protoc_insertion_point(field_release:apipb.UnknownCapability.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UnknownCapability::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:apipb.UnknownCapability.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace apipb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::apipb::AddPathCapabilityTuple_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apipb::AddPathCapabilityTuple_Mode>() {
  return ::apipb::AddPathCapabilityTuple_Mode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_capability_2eproto
